< Static Typing >
정적 타이핑
타입을 선언하고 선언한 타입에 맞는 값만이 할당 또는 반환되어야 한다는 것.

< Type Inference >
타입 추론
ex) 
// ts
let a = 5;
a = 'Hello';
-> a에 빨간줄 에러 뜸. let a: number 메세지 Type 'Hello' is not assignable to type 'number'.

=> 타입스크립트에서는 타입 표기가 없는 경우 우리가 쓴 코드를 읽고 분석하여 타입을 유추해낼 수 있다.

< Type Annotations >
타입 명시
변수를 선언할 때, 변수 값의 타입을 명시함으로써 변수 값의 데이터 타입을 지정하는 것.
syntax ex)
let x:string = "나는 영원한 문자열";

< TypeScript Interface >
Inferface이름은 대문자로 시작해야 함.
인터페이스를 타입으로 가지는 값은 인터페이스의 구조를 그 값으로 가지도록 강제된다.
?붙일경우 선택적 프로퍼티가 됨. 함수에 작성 시 있어도되고 없어도 되는 프로퍼티가 됨.
프로퍼티뿐만 아니라 메소드(객체 내에서 선언된 함수)도 인터페이스 내에서 정의할 수 있다.
Readonly 프로퍼티는 읽기전용 프로퍼티로 객체 생성시 할당된 프로퍼티의 값은 그 후에 바꿀 수 없다.
인터페이스는 코드가 js로 따로 컴파일되지 않음

< TypeScript Enum & literal >
Enum이란 연관된 아이템들을 함께 묶어서 표현할 수 있는 수단 
Enum은 Inferface와 다르게 js파일에 컴파일돼서 나타남 -> Enum이 런타임에 존재하는 실제 객체라는 것을 보여줌

// ts
enum GenderType {
    Male,
    Female,
    GenderNeutral,
}

// js
enum GenderType {
    Male = 0,
    Female = 1,
    GenderNeutral = 2,
}
=> 이렇게 자바스크립트파일에 숫자로 할당됨. 이것이 숫자 열거형 Numeric Enum이라는 것

나는 숫자가 아닌 문자열로 할당되기를 원한다!
String Enum도 허용됨

enum GenderType {
    Male = 'male',
    Female = 'female',
    GenderNeutral = 'genderNeutral',
}


리터럴타입 예시
interface ~ {
    .
    .
    gender : 'male' | 'female' | 'genderNeutral'
    .
    .
}
파이프 표시를 넣고 스트링을 구별시키면 됨!
gender : 'male'

< Any, Union Type, Type Aliases, Type Guards >
Any Type
되도록이면 안쓰는게 좋음. 왜냐? 타입에 관한 더 많은 정보를 명시할 수록 더 좋으니까
-> 타입에러를 잡기 쉽고 효과적인 코드의 유지보스가 가능함 
그럼 어떨 때 쓰면 좋을까? 타입 명시가 어려운 경우

Union Type
무슨 타입이 변수에 들어올 지는 정확히 모르지만 변수의 타입이 무조건 숫자 아니면 문자열일 때
제한된 몇가지 타입들을 동시에 지정하고 싶을 때
let someValue:number|string

Type Aliases
같은 조합이 계속 반복될 경우 코드를 향상 시킬 수 있는 방법
let someValue:number|string 이런 유니언 타입을 가지는 변수나 함수가 많을 경우
코드 내에 여러 군데 있다고 가정했을 때 같은 코드를 반복하는 것보다는 이러한 조합 자체를 타입으로 지정하고 재활용하는 것이 좋음

Type Guard
Union Type을 사용 할 때 typeof를 사용하여 코드검증을 수행하는 것


< 함수의 타입 명시 >
함수의 반환(return) 타입
함수의 매개변수(Parameter) 타입

함수의 반환(return) 타입 명시하기
function 함수이름(매개변수1, 매개변수2):함수의 반환타입 {

}

선택적 매개변수
매개변수 뒤에 ? 붙여주기! 있어도되고 없어도 되는 선택적 매개변수로 변환
단, 선택적 매개변수들은 필수 매개변수 뒤에 위치해야 함

기본 매개변수(Default Parameter)

Arrow function
// 기존 함수
function add (num1, num2){
    return num1 + num2;
}

// 화살표 함수
const add = (num1, num2) => num1 + num2;


< 객체 지향 프로그래밍 >
타입스크립트에서는 객체지향 프로그래밍의 클라스를 정의하고 사용할 수 있다.

온라인쇼핑 어플리케이션을 구축한다 했을 때 
주문에 대한 정보, 고객에 대한 데이터, 장바구니의 물건 담기, 주문 결제 처리하기, 고객 정보 업데이트 하기 등 수많은 데이터를 다룰 변수와 함수들이 필요함
이처럼 프로젝트 규모가 커지게 되면 프로그램을 작동시키기 위해서 수많은 코드들이 쓰여지게 됨
그런데 만약 코드들이 여기저기 흩어져 있으면 가독성이 떨어지는 유지보수가 힘든 프로그램이 되버림
객체지향 프로그래밍은 이러한 문제를 해결하기 위해 연관된 변수와 함수들을 한 덩어리로 묶어서 구조화하여 표현하는 프로그래밍 스타일을 말한다.

손님이 물건을 장바구니에 담아서 주문, 결제할 수 있다.
손님, 물건, 장바구니, 주문, 결제 <- 객체지향 프로그래밍에서 잠재적 객체
어플리케이션을 실제 세상에 존재하는 객체와 같은 단위로 쪼개고 객체(연관된 변수와 함수들의 집합)들이 서로 상호 작용함으로써 시스템이 동작되는 것을 객체지향 프로그래밍이라고 한다.

객체는 클라스를 통해서 만들어 질 수 있고
클라스는 객체가 어떤 모습을 가질지 정의하고 묘사하는 객체의 뼈대, 설계도, 생산틀이라고 생각하면 됨

클라스 내에 정의 된 변수를 '프로퍼티'라 하고
클라스 내에 정의 된 함수를 '메소드'라고 부른다.


< 생성자(Constructor), 접근 제한자(Access Modifiers), Getter 와 Setter >
생성자(Constructor)
객체지향언어에는 생성자라고 불리는 아이가 있는데 코드를 명확하게 하고 향상시켜 줌.
모든 클라스에는 생성자를 가질 수 있음. 클라스로부터 객체를 생성할 때 호출되며 객체의 초기화를 담당함
클라스를 통해서 객체를 생성할 때, Constructor에 정의된 매개변수의 값이 Arguments로 전달 되어야 함.
전달되는 매개변수를 강제하고 있는데, 객체가 생성될 때 반드시 할당되지 않아도 되는 값들로 만들고 싶다면 ?를 이용한 선택적매개변수를 이용하면 됨

접근 제한자(Access Modifiers)
할당된 초기값을 다른 value로 쉽게 바꿀 수 있음
하지만 우리가 프로그램을 만들 때 외부로부터 데이터를 보호하기 위해 접근 제한자 기능을 이용함.
클라스 속 멤버 변수(프로퍼티)와 메소드에 적용될 수 있는 키워드
클라스 외부로부터의 접근을 통제 -> 버그를 줄이고 코드의 안전성 향상시켜 줌
크게 3가지로 나뉨
Public(클라스 외부에서 접근 가능함)
Private(클라스 내부에서만 접근 가능 클라스의 외부에서 접근 불가능(비공개 멤버))
Protected(클라스 내부, 그리고 상속받은 자식 클라스에서 접근 가능)

Public 멤버를 노출시키기 위해서 Public 키워드를 굳이 명시할 필요는 X


Getter & Setter
비공개로 설정된 객체 멤버 변수에 접근하여 값을 읽거나 쓰기 위해서 Getter와 Setter를 이용.
클라스 내에서 Get과 Set 키워드를 사용하여 Getter와 Setter을 선언할 수 있음

ex)
class ~~ {
    private _name: string;
    .
    .
}

비공개 프로퍼티의 이름 앞에 _(underscore) 밑줄을 긋는 것은 많은 언어에서 컨벤션으로 사용 됨.
프라이빗 멤버라는 것을 나타내기 위한 암묵적으로 약속된 방법

// 읽게해주는 Getter
get name() {
    // 게터가 불려질 때 실행될 코드
    return this._name;
}


// 새로운 값으로 재할당 가능하게 해주는 Setter
set name(value:string) {
    this._name = value;
}
(전달된 매개변수와 타입)
{전달된 매개변수의 값을 비공개 name 매개변수의 값으로 재할당하는 코드를 넣어줌}



객체가 생성될 때 Constructor의 매개변수로 전달된 값은 객체의 프로퍼티 값으로 자동으로 그 값이 초기화되고 할당됨!

